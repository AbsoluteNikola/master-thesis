#import "@preview/curryst:0.5.1": rule, prooftree

= Реализация языка на фреймворке

В предыдущей главе была показана реализация фреймворка для проверки и вывода уточняющих типов, но помимо реализации самого фреймворка также надо оценить его применимость. Показателем качества и применимости фреймворка предлагается считать по следующим пунктам
+ Пользователю не требуется работать с предикатами, если он самостоятельно их не модифицирует
+ Контракты достаточно мощные, для реализации необходимых возможностей модельного языка
+ Предоставленные ограничения покрывают потребности проверки уточняющих типов в модальном языке

Для этого на фреймворке была реализована проверка уточняющих типов для подмножества языка ocaml со следующими возможностями
+ Ветвление и рекурсия
+ Функции высших порядков
+ Вывод предикатов
+ Параметрический полиморфизм и вывод типов
+ Полиморфные алгебраические типы данных
+ Сопоставление с образцом

Данный список возможностей реализован во многих функциональных языках и способен показать применимость фреймворка. Сам язык в дальнейшей работе будет называться модельный язык. Важно понимать, что работа велась только над подмножеством ocaml с указанными возможностями

== Синтаксис языка
Основные конструкции языка представлены в следующем виде на @f-lang-1 в синтаксисе LBNF (Labeled BNF), где каждому выражению присвоено свое имя.

#figure(
  ```
  -- 0
  ConstInt.     Term ::= Integer;
  -- true
  Bool.         Term ::= ConstBool ;
  -- x
  Var.          Term ::= VarIdent;
  -- Cons(x, xs)
  ConApp.       Term ::= ConIdent ConAppArgs;
  -- foo(a, b, c)
  FunApp.       Term ::= VarIdent "(" [FuncAppArg] ")";
  -- if (true) {x} else {y}
  If.           Term ::=
    "if" "(" FuncAppArg ")" "{" Term "}" "else" "{" Term "}";
  -- let rec x = 0 in x
  Let.          Term ::= Decl Term ;
  -- (x) => {x}
  Fun.          Term ::= "(" [FunArgName] ")" "=>" "{" Term "}" ;
  -- x + y
  Op.           Term ::= FuncAppArg IntOp FuncAppArg;
  -- switch (xs) { | Nil => 0}
  Switch.       Term ::=
    "switch" "(" VarIdent ")" "{" [SwitchCase] "}";
  ```,
  caption: "Синтаксис основных конструкций"
)<f-lang-1>

Объявление функций и переменных происходит через связку `let in`, где у переменных и функций могут присутствовать аннотации типов как показано на @f-lang-2

#figure(```
/*@ val inc: x:int => int[v|v == x + 1] */
let inc = (x) => {
    x + 1
};
```,
caption: "Пример аннотации типов в функции abs"
)<f-lang-2>

Синтаксис типов представлен на @f-lang-3.  Предикаты описаны эквивалентно тому, что представлено во фреймворке

#figure(
  ```
  KnownRefinement.   Refinement ::= "[" VarIdent "|" Pred "]";
  UnknownRefinement. Refinement ::= "[" "?" "]";
  SimpleRefinement.  Refinement ::= ;

  -- types
  TypeFun.             RType ::= FuncArg "=>" RType ;
  TypeRefined.         RType ::= BaseType Refinement;
  TypeData.            RType ::= VarIdent TypeDataArgs Refinement;
  _.                   RType ::= "(" RType ")";
  ```,
  caption: "Синтаксис типов и уточнений"
)<f-lang-3>

Важным замечанием будет уточнить то, что в самой реализации есть два синтаксиса и AST сгенерированных BNFC
+ Представлен на листингах выше, разделены типы и выражения
+ Объединяет типы и выражения под один тип, в первую очередь это сделано для того что бы типы и выражения имели одни области видимости и позволяли делать переименование переменных между друг другом

По сути оба синтаксиса эквиваленты друг другу, но отличаются представлением AST и упрощением некоторых узлов. Конвертация из AST полученного после разбора текста в первый синтаксис реализована наивной конвертацией из одного дерева в другое.
На основе сгенерированного BNFC AST, генерируется следующая (см. @f-lang-4) сигнатура языка для free-foil.
На основе представленного типа данных можно штатными методами вывести стандартные классы типов необходимые для работы
free-foil `deriving (Generic, Functor, Foldable, Traversable)`, а также `Bifunctor, Bifoldable, Bitraversable` за счет инструментов из библиотеки bifunctors

#figure(
  ```haskell
  data TermSig scope term where
    ConstIntSig :: Integer -> TermSig scope term
    BooleanSig :: ConstBool -> TermSig scope term
    ConstructorSig :: ConIdent -> TermSig scope term
    IfSig :: term -> term -> term -> TermSig scope term
    LetSig :: term -> scope -> TermSig scope term
    LetRecSig :: term -> scope -> scope -> TermSig scope term
    FunSig :: scope -> TermSig scope term
    AppSig :: term -> term -> TermSig scope term
    AnnSig :: term -> term -> TermSig scope term
    OpExprSig :: term -> Op -> term -> TermSig scope term
    SwitchSig :: term -> [term] -> TermSig scope term
  ```,
  caption: "Сигнатура основных конструкций языка"
)<f-lang-4>

Типы представленные в том же типе и сигнатуре следующим образом

#figure(
  ```haskell
  TypeRefinedSig :: term -> scope -> TermSig scope term
  TypeFunSig :: term -> scope -> TermSig scope term
  TypeForallSig :: scope -> TermSig scope term
  TypeDataSig :: VarIdent -> [term] -> scope -> TermSig scope term
  ```,
  caption: "Сигнатура типов языка"
)<f-lang-5>

Также надо обозначить тип, которые описывает как различные наборы переменных расширяют область видимости.
В нашем случае есть только три конструкции расширяющие область видимости (см. @f-lang-6), это
+ `PatternNoBinders` и `PatternSomeBinders`, которые описывают расширение области от $0$ до $n$ переменных в конструкции `switch case`, например
  ```ml
  switch (xs) {
    | Nil        => ys
    | Cons(h, t) => append(t, ys)
  }
  ```
+ `PatternVar` описывающее расширение области ровно одной переменной. Применяется во всех остальных случаях

#figure(
  ```haskell
  data Pattern o i where
    PatternVar :: (Foil.NameBinder o i) -> Pattern o i
    PatternNoBinders :: Pattern o o
    PatternSomeBinders ::
      (Foil.NameBinder o i1) ->
      (Pattern i1 i2) ->
      Pattern o i2
  ```,
  caption: "Тип для расширения области видимости"
)<f-lang-6>


Само же AST будет выглядеть как синоним для `Foil.AST и Foil.ScopedAST` примененные к сигнатуре языка.

```haskell
type Term = Foil.AST Pattern TermSig
type ScopedTerm = Foil.ScopedAST Pattern TermSig
```

Поскольку все конструкции языка описываются через рекурсивную связку `Node` и `ScopedAst` из free-foil, то удобным будет добавить синонимы сопоставления с образцом, по следующему формату

#figure(
  ```haskell
  pattern Let :: Pattern o i -> Term o -> Term i -> Term o
  pattern Let binder val body = Foil.Node
    (LetSig val
      (Foil.ScopedAST binder body))
  ```,
  caption: "Синонимы сопоставления с образцом для AST"
)<f-lang-7>

Такие синонимы сделаны для каждой конструкции в языке.

== Реализация контрактов фреймворка
Для реализации контракта `IsType` нужно представить две метода
+ `withPred` для извлечения предиката из типа, проведения над предикатом вычислений и обратное конструирование типа.
  В случае подмножества ocaml, для которого реализуется проверка типов, предикаты есть только у типов данных. В AST они разделены на два вида

  + `TypeRefined` - отвечающий за базовые типы, например `int[v|v >= 0]`, `bool[b|b]`
  + `TypeData` - отвечающий за пользовательские алгебраические типы данных, например `list(int)[v|len(v) >= 0]`

  Реализация для TypeRefined показана на @f-lang-8.
  #figure(
  ```haskell
  withPred (TypeRefined base (PatternVar v) p) f =
    case (Foil.assertDistinct v, Foil.assertExt v) of
      (Foil.Distinct, Foil.Ext) ->
        case f $ Refinements.WithPred v p of
          (res, Refinements.WithPred v' p') ->
            ( Just res
            , TypeRefined base (PatternVar v') p')
  ```,
  caption: [Реализация `withPred` для базовых типов]
  )<f-lang-8>
  Если подробнее рассмотреть код по строчно, то алгоритм выглядит следующим образом
  - На 1 строчке разбираем тип на базовый - base, переменную `v` связывающую данные с предикатам, и предикат p. На вход принимаем функцию `f` для модификации предиката
  - 2 и 3 строчки нужны для компилятора haskell, что бы сказать ему что классы free-foil будут выполнять и в области расширенной переменной `v`
  - На 4 строке Пакуем `v` и `p` в обертку `WithPred`, и применяем к ней `f`
  - На 5 строке распаковываем результат вычисления функции и новый предикат
  - На 6 и 7 строке возвращаем вычисление, полученное из применения функции `f` и конструируем тип с новым предикатом, но тем же базовым типов

  Для `TypeData` реализация будет аналогичным. Для других же типов, например функций, где предикатов нет, реализация будет выглядеть тривиально. Функцией для предикатов мы ничего не могли посчитать, потому что нет предикатов, а тип остается таким же без модификации
  #figure(
  ```hs
  withPred t _ = (Nothing, t)
  ```,
  caption: [Реализация `withPred` для типов без предикатов]
  )<f-lang-10>

+ `toTypeSignature` для преобразования типов в формат сопоставимый с сортами SMT-LIB.
  Для реализации нужно рекурсивно обойти тип как показано на @f-lang-11, отбросить предикат и сконвертировать в формат сигнатуры типов из фреймворка.

  #figure(
  ```haskell
  ...
  toTypeSignature (TypeRefined BaseTypeInt _ _)
    = Refinements.IntType
  toTypeSignature (TypeRefined BaseTypeBool _ _)
    = Refinements.BoolType
  toTypeSignature (TypeData name args _ _) = Refinements.DataType name' args'
    where
      name' = Refinements.Id $ getRawVarId name
      args' = map Refinements.toTypeSignature args
  toTypeSignature (TypeFun _ argT retT) = Refinements.FunType
    (Refinements.toTypeSignature argT)
    (Refinements.toTypeSignature retT)
  ...
  ```,
  caption: [Реализация `toTypeSignature`]
  )<f-lang-11>

  Контракт для предикатов `IsPred` требует больше методов, но концептуально они довольно простые
  + `isUnknown` - показывает является ли предикат заглушкой или нет
    ```haskell
    isUnknown Unknown = True
    isUnknown _ = False
    ```
  + `mkHornVar` - Создает предикат в виде применения переменной Хорна
    ```haskell
    mkHornVar name vars = HVar
      (VarIdent name)
      (Foil.Var <$> vars)
    ```
  + `mkAnd` и `mkEq` - создают узлы применения операторов с одноименным названием к двум других предикатам
  + `toPredicate` - тривиальная обход AST предикатов и преобразование его в формат фреймворка

== Проверка типов

Проверка типов представляет из себя двунаправленную проверку типов, где выражения делятся на два вида:
+ выражения, тип которых можно вывести из контекста $Gamma #sym.tack.r e ==> t$
+ выражения, тип которых известен и его надо проверить в контексте $Gamma #sym.tack.r e <== t$

Результатом проверки типов является успех или ошибка проверки базовых типов, а также, в случае успехов, ограничения, корректность которых проверятся при помощи SMT-решателя.

Базой для проверки уточняющих типов является проверка подтипирования, описываемая следующими правилами
#figure(
  prooftree(
    rule(
      name: [Sub-Base],
      $Gamma #sym.tack.r b{v_1:p_1} #sym.prec colon b{v_2:p_2}$,
      $Gamma #sym.tack.r forall v_1 : b . p_1 => p_2[v_2 := v_1]$
    )
  ),
caption: "Правило подтипирования базовых типов"
)

#figure(
  prooftree(
    rule(
      name: [Sub-Base],
      $Gamma #sym.tack.r x_1:s_1 -> t_1 #sym.prec colon x_2:s_2 -> t_2$,
      $Gamma #sym.tack.r s_2 #sym.prec colon s_1$,
      $Gamma; x_2:s_2 #sym.tack.r t_1[x_1:=x_2] #sym.prec colon  t_2$,
    )
  ),
caption: "Правило подтипирования функций"
)<f-lang-12>

#figure(
  prooftree(
    rule(
      name: [Sub-Base],
      $Gamma #sym.tack.r x_1:s_1 -> t_1 #sym.prec colon x_2:s_2 -> t_2$,
      $Gamma #sym.tack.r s_2 #sym.prec colon s_1$,
      $Gamma; x_2:s_2 #sym.tack.r t_1[x_1:=x_2] #sym.prec colon  t_2$,
    )
  ),
caption: "Правило подтипирования функций"
)

Аналогичное правилу подтипирования базовых типов на @f-lang-12 используется и для пользовательских типов данных, только с учетом проверки подтипирования аргументов типа

Сами функции проверки и вывода представлены на @f-lang-13 и @f-lang-14. `Env` это синоним для окружения из фреймворка и представлен в виде `type Env = LR.Env TermSig Pattern`

#figure(
 ```haskell
  check :: (F.DExt F.VoidS i) =>
    -- Описывает текущий набор переменных в области видимости
    F.Scope i ->
    -- Текущее окружение из переменных и их типов
    Env i ->
    -- Выражение для проверки
    Term i ->
    -- Тип выражения (типы и выражения представлены в одном типе)
    Term i ->
    -- На выходе получаем ограничения
    CheckerM LR.Constraint
  ```,
caption: "Сигнатура функции проверки типов"
)<f-lang-13>

#figure(
 ```haskell
  synths ::
    (F.DExt F.VoidS i) =>
    F.Scope i ->
    Env i ->
    -- Выражение тип которого надо вывести
    Term i ->
    -- На выходе получаем ограничения и тип выражения
    CheckerM (LR.Constraint, Term i)
  ```,
caption: "Сигнатура функции вывода типов"
)<f-lang-14>

На основе рекурсивного вызова `check` и `synths` производится двунаправленная проверка базовых типов и генерация ограничений

=== Ветвление
Для понимания проблемы которая возникает при ветвлении надо рассмотреть простой код на @f-lang-15. В нем на основе if нужно в разные ветки предоставить информацию что $x >= 0$ или $x < 0$. Но в конце рекурсивного обхода, при проверка выражения `x` (ветка истинности), достав из окружения тип переменной `x` получим $x : {v : "int" | "true"}$, что не является подтипом ${v : "int" | v >= 0}$. Для этого нужно усилить предикат в типе ${v : "int" | "true"}$, добавив в него равенство между переменными $x$ и $v$. В итоге тип у $x$ будет выглядеть как $x : {v : "int" | "true" and x = v}$

#figure(
  ```ml
  /*@ val abs : x:int => int[v|0<=v] */
  let abs = (x) => {
      let pos = x >= 0;
      if (pos) {
          x
      } else {
          0 - x
      }
  };
  ```,
caption: "Функция получения модуля числа"
)<f-lang-15>

После усиления предиката ограничения будут выглядеть следующим образом
$
  & forall x, c, y, v. (c = 0 <= x) => c => v = x => (0 <= v ) \
  & forall x, c, y, v. (c = 0 <= x) => not c => v = 0 - x => (0 <= v )
$

Для данной операции фреймворк предоставляет готовую функцию для работы с окружением (см. @f-lang-16), которое делает показанное усиление предиката за пользователя. Сама же функция усиления предиката показана на @f-lang-17

#figure(
```haskell
lookupEnvWithStrengthening ::
  (Foil.Distinct o, Bifunctor sig, IsType sig binder) =>
  Env sig binder o ->
  Foil.Name o ->
  Foil.AST binder sig o
lookupEnvWithStrengthening env name = singletonT name resTyp
  where
    resTyp = lookupEnv env name
```,
caption: "Поиск в окружении с автоматическим усилением предиката"
)<f-lang-16>

#figure(
```haskell
singletonT ::
  (Foil.Distinct n, IsType sig binder) =>
  -- Имя переменной
  Foil.Name n ->
  -- Тип с предикатом
  Foil.AST binder sig n ->
  -- Тип с усиленным предикатом
  Foil.AST binder sig n
singletonT varName typ = snd $ withPred typ $ \(WithPred pNameBinder p) ->
  case (Foil.assertDistinct pNameBinder, Foil.assertExt pNameBinder) of
    (Foil.Distinct, Foil.Ext) ->
      let
        newPred = mkAnd
            p -- Старый предикат
            ( mkEq -- x = v
              (Foil.Var $ Foil.sink varName)
              (Foil.Var $ Foil.nameOf pNameBinder)
            )
      in ((), WithPred pNameBinder newPred)
```,
caption: "Поиск в окружении с автоматическим усилением предиката"
)<f-lang-17>
=== Вывод предикатов

Весь вывод предикатов реализован в фреймворке и как его пользователю нужно сделать только три вещи
+ Сделать передачу изменяемого состояния с переменными Хорна
+ Реализовать обход типов и вызвать замену заглушек на применение переменных Хорна из фреймворка.
+ Во время проверки уточняющих типов вызывать реализованную в пункте два функции

=== Вывод типов

Реализованная проверка типов поддерживает вывод типов и параметрический полиморфизм используя алгоритм Хиндли — Милнера, но данная часть работы напрямую не относится к представленной теме диплома. Поэтому хочется подсветить только основной момент, что Вч местах создания экземпляра полиморфной функции или типа данных с явным указанием типов нужно проставить у типов в предикаты заглушки

=== Типы данных и сопоставление с образцом
Для пользовательских алгебраических типов данных в первую очередь реализована поддержка работы с предикатами и их представление в сигнатуре типов, которые уже были рассмотрены. Вторым важным критерием была поддержка неинтерпретируемых функций, которые критичны для кодирования логики работы с пользовательскими типами. Ярким примером их использования может быть функция кодирующая длину списка.

#figure(
```haskell
/*M len : _:list('a) => int */

type list('a) =
  | Nil                      => [v| len(v) == 0]
  | Cons (x:'a, xs:list('a)) => [v| len(v) == 1 + len(xs)]
  ;

/*@ val append :
  xs:list('a) => ys:list('a) => list('a)[v|len(v) == len(xs) + len(ys)] */
let rec append = (xs, ys) => {
  switch (xs) {
    | Nil        => ys
    | Cons(h, t) => append(t, ys)
  }
};
```,
caption: "Использование неинтерпретируемых функций для кодирования длины списка"
)<f-lang-18>

На @f-lang-18 показано использование функции `len` в конструкторе `Cons` гарантирующем, что длина списка увеличивается на 1, а также в функции `append`, гарантирующая что длина результирующего списка равно сумме длин списков поданных на вход `xs` и `ys`

Сами неинтерпретируемые функции задаются как пара из имени и типа. В формат фреймворка они конвертируются при помощи `mkMeasure`, которая принимаем имя и тип реализующий контракт `IsType`

== Резюме
В данной главе описана реализация проверки уточняющих типов на примере подмножества языка ocaml. Язык поддерживает
+ Ветвление и рекурсия
+ Функции высших порядков
+ Вывод предикатов
+ Параметрический полиморфизм и вывод типов
+ Полиморфные алгебраические типы данных
+ Сопоставление с образцом

В данной реализации показано применение представленного в работе фреймворка и его возможностей. Реализованная проверка типов показывает следующие важные аспекты
+ Применимость выбранной мощности предикатов для верификации свойств программного обеспечения
+ Предоставленные фреймворком ограничения полностью покрывают ограничения генерируемые при проверке типов
+ При реализации проверки типов не пришлось работать с предикатами самостоятельно, всю работу на себя берет фреймворк
+ Не было необходимости самостоятельно работать с SMT-решателями
