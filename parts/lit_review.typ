

= Обзор литературы и существующие решения

== Уточняющие типы

Уточняющие типы (refinement types) - это расширение классических систем типов, позволяющее описывать не только принадлежность значения к некоторому базовому типу (например, int или bool), но и накладывать на значения дополнительные логические ограничения в виде предикатов. Формально, уточняющий тип записывается как
$v : T | P(v) $, где $T$ - базовый тип, а $P(v)$ - булев предикат над значением $v$

Стандартные системы типов позволяют гарантировать, что, например, переменная имеет тип int, но не могут выразить дополнительные свойства, такие как ограниченность диапазона. Это приводит к тому, что даже хорошо типизированные программы могут содержать ошибки времени выполнения, связанные с некорректными значениями, например:
- Деление на ноль: тип int не гарантирует, что делитель отличен от нуля.
- Выход за границы массива: тип индекса массива - int, но не гарантируется, что индекс находится в допустимом диапазоне.
- Нарушение инвариантов структур данных: например, что список отсортирован

С помощью уточняющих типов можно явно формализовать такие ограничения. Например, тип натуральных чисел может быть определён как $"type" "nat" = {v : "int" | 0 <= v}$

Семантически, уточняющий тип определяет подмножество значений базового типа, для которых предикат истинный $ bracket.l.double  {v : T | P(v)} bracket.r.double = {x in bracket.l.double T bracket.r.double | P(x) = "true"}$

== Обзор языков с уточняющими типами

=== LiquidHaskell
Это система верификации и проверки типов для языка Haskell, которая расширяет систему типов Haskell добавлением уточняющих типов в виде аннотаций в программный код. Система предикатов поддерживает логику первого порядка без кванторов с неинтерпретируемыми функциями и линейной арифметикой. Для проверки соблюдения свойств программы используется SMT-Решатель. Применяется как плагин к компилятору GHC, что позволяет легко интегрировать систему в существующие проекты. Пример кода показан на @lit-1
#figure(
  ```haskell
  {-@ incr :: x:{Int | x >= 0} -> {v:Int | v = x + 1} @-}
  incr x = x + 1
  ```,
  caption: "Пример кода на LiquidHaskell"
)<lit-1>
Особенности:
  - Возможность использовать в ограниченных участках кода, без необходимости вносить изменения в весь проект
  - Отсутствие накладных расходов во время выполнения
  - Интеграция с экосистемой языка Haskell
  - Поддержка нескольких SMT-решателей
  - По сравнению с другими инструментами мощность языка предикатов специально ограниченна в угоду автоматизации

=== F\*
F\* - функциональный язык программирования с зависимыми типами, разработанный Microsoft Research для формальной верификации программ. Основной особенностью является генерация верифицированного кода в код на языках C, OCaml, F\# и WebAssembly, сохраняя доказанные свойства. F\* использует зависимые типы дополняя их уточнениями, которые могут содержать логику высшего порядка. Такой выбор системы типов дает мощные инструменты для верификации программного обеспечения, но требует от программиста больших усилий для доказательства корректности, а также направления проверки типов в нужное русло. Поэтому язык используется для верификации критически важных систем, с последующей генерацией кода в один из предоставленных языков программирования. Из-за этих свойств применять язык F\*, как язык общего назначения проблематично

#figure(
  ```
  let abs (x:int) : Tot (y:int{y >= 0}) =
    if x < 0 then -x else x
  ```,
  caption: "Пример кода на F*"
)<lit-2>

=== Dafny
Dafny - язык программирования, ориентированный на разработку верифицированных программ. Dafny сочетает в себе возможности императивного, функционального и объектно-ориентированного программирования с богатой системой статической верификации.
Система уточняющих типов в Dafny реализована через аннотации, включающие предусловия, постусловия и инварианты:
- Предусловия: задаются ключевым словом requires и определяют условия, которые должны выполняться перед вызовом метода.
- Постусловия: задаются ключевым словом ensures и определяют гарантии, предоставляемые методом после его выполнения.
- Инварианты циклов: задаются ключевым словом invariant и определяют свойства, которые сохраняются на каждой итерации цикла.
Dafny верифицирует программы с использованием SMT-решателя Z3. Этот процесс проверяет, что реализация программы соответствует её спецификации. Когда Dafny не может автоматически доказать правильность программы, пользователь может помочь системе, предоставив дополнительные спецификации.

#figure(
  ```
  method Max(a: array<int>) returns (m: int)
    ensures forall k :: 0 <= k < a.Length ==> a[k] <= m
  {
    m := a[0];
    var i := 1;
    while i < a.Length
      invariant 0 <= i <= a.Length
      invariant forall j :: 0 <= j < i ==> a[j] <= m
    {
      if a[i] > m { m := a[i]; }
      i := i + 1;
    }
  }
  ```,
  caption: "Пример кода на Dafny"
)<lit-2>

=== Why3
Why3 - система верификации программ, разработанная специально для проверки алгоритмического уровня, а не программного. Why3 предлагает свой язык WhyML, который сочетает функциональный стиль программирования с императивными конструкциями.
В Why3 спецификации записываются в виде предусловий и постусловий функций, аналогично Dafny. Однако Why3 также поддерживает механизм уточнения через клонирование модулей, что позволяет реализовывать абстрактные спецификации и постепенно уточнять их. Why3 генерирует условия верификации, которые затем проверяются с помощью различных SMT-решателей. Система поддерживает интеграцию с различными решателями, включая Z3, Alt-Ergo, CVC4.

#figure(
  ```
  function sum (n: int) : int
    requires n >= 0
    ensures result = n * (n + 1) / 2
  = if n = 0 then 0 else n + sum (n - 1)
  ```,
  caption: "Пример кода на Why3"
)<lit-3>

=== Flux
Flux - это система уточняющих типов для языка Rust, показывающая, как логические уточнения могут работать совместно с механизмами владения (ownership) Rust для обеспечения верификации на основе уточняющих типов. Flux использует SMT-решатели для проверки логических ограничений в уточнениях типов. Система автоматически выводит инварианты для контейнеров, что значительно упрощает верификацию программ, работающих с коллекциями.
#figure(
  ```
  #[flux::sig(fn (a: &strg i32[@n]) -> i32[n+1])]
  fn incr(a: &mut i32) {
    *a += 1;
  }
  ```,
  caption: "Пример кода на Flux"
)<lit-4>

== Резюме

Современные системы уточняющих типов, такие как LiquidHaskell, Why3 и Flux, демонстрируют впечатляющие возможности в верификации программ, но их архитектурные особенности создают барьеры для распространения технологии уточняющих типов. Анализ их реализации и опыта интеграции (например, Flux для Rust, LiquidHaskell для Haskell) выявляет проблемы, которые универсальный фреймворк мог бы решить.
Архитектурная фрагментация становится основной преградой для повторного использования наработок. Каждая система, как показано в примере с Flux, глубоко интегрируется с особенностями базового языка. Это приводит к дублированию усилий: реализация таких компонентов, как управление SMT-решателями или генерация условий верификации, воссоздается заново для каждого языка. Универсальный фреймворк мог бы стандартизировать представление предикатов и условий корректности, предоставив API для работы с уточняющими типами. Это позволит сократить время реализации проверки уточняющих типов в целевом языке и сосредоточиться на других компонентах языка

