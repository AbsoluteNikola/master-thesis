= Реализация

В предыдущей главе были описаны требования и контракты которые должен предоставлять итоговый фреймворк. В этой главе будет рассмотрена реализация самого фреймворка, а в следующей главе его применение для реализации проверки уточняющих типов в подмножестве языка ocaml

Языком для реализации был выбран Haskell из следующих соображений
- Богатая система типов позволяющая давать гарантии корректности при построении и обходе выражений, а также поддержка полиморфизма при помощи классов типов
- Поддержка алгебраических типов данных и сопоставления с образцом, позволяющие легко моделировать синтаксис модельного языка и упрощающие рекурсивных обход синтаксических деревьев
- Система типов позволяет гарантировать отсутствие побочных эффектов там где они не нужны. Это сильно повышает тестируемость и предсказуемость кода.
- Богатая экосистема. На Haskell уже реализованы уточняющие типы для самого языка в фреймворке LiquidHaskell. LiquidHaskell является ярким примером реализации уточняющих типов, на который можно ссылаться при реализации. Также в экосистеме есть необходимый набор библиотек для парсеров, работы с SMT-решателями, форматирования ошибок и работы со сложными рекурсивными структурами данных

== Используемые инструменты

Данная работа сильно полагается на два инструмента написанных на Haskell.

=== free-foil
Проверка типов являются важными компонентами реализации языка программирования, ответственными за обеспечение безопасности типов и выявление ошибок в момент компиляции. Одним из основных аспектов проверки типов является управление областями видимости - процесс отслеживания объявлений переменных и их типов в различных участках кода. Несмотря на кажущуюся простоту, управление областями в средствах проверки типов сопряжено с многочисленными трудностями, которые усложняют реализацию и приводят к ошибкам.

Основные проблемы возникают в случаях
- Использования того же имени, что и у переменной выше по области видимости
- Переименовании переменных так, чтобы избежать конфликта имен с уже существующими переменными


+ Концепция
  Free foil использует идею предложенную в foil для отслеживания областей видимости. Каждое выражение параметризуется фантомным типом `n :: S` который определяет область в которой это выражение используется. Используя возможности системы типов Haskell, в момент компиляции проверяется, что работа с выражениями идет строго с учетом их области видимости.

  На основе предоставленной пользователем сигнатуры своего языка, которая включает в себя все используемые конструкции, генерируется абстрактное синтаксическое дерево параметризованное фантомными типами как указано выше.

+ Представление абстрактного синтаксического дерева
  #figure(
  ```haskell
  -- Рекурсивный тип описывающий выражения в области n
  data AST binder sig n where
    -- | Свободная переменная в области n.
    Var :: Foil.Name n -> AST binder sig n
    -- | Другие синтаксические конструкции в области n
    --   основанные на сигнатуре языка
    Node
      :: sig (ScopedAST binder sig n) (AST binder sig n)
      -> AST binder sig n
  -- Рекурсивный тип описывающий подвыражение
  -- с расширенной областью l
  data ScopedAST binder sig n where
    ScopedAST
    -- | Тип описывающий как расширяется область из n в l
      :: binder n l
    -- | Выражение в области l
      -> AST binder sig l
      -> ScopedAST binder sig n
  ```,
  caption: "Описание абстрактного синтаксического дерева во free-foil"
  )<f-realization-1>

  - sig - сигнатура языка, описывающая конструкции языка
  - binder - тип описывающий то как расширяется область видимости из n в l. binder может быть как введением одной переменной например $lambda x. t$, где все выражение имеет область типа n, а $t$ уже имеет область типа $l$. введение переменной $x$ расширяет область из n в l. Тип binder может быть и сложнее, описывая введение более чем одной переменной в область видимости, например в конструкция сопоставления с образцом $"Cons"("x", "xs") -> t$.
  - n и l - фантомные типы описывающие текущую область видимости

+ Подстановка

  Имея показанную на @f-realization-1 структуру синтаксического дерева можно предоставить обобщенную подстановку не зависящую от модельного языка. Подстановка реализована на основе класса `Sinkable` гарантирующего безопасное переименование переменных c  учетом областей видимости.

Подводя итог, free-foil дает следующие преимущества которые сильно помогут при реализации фреймворка
+ Безопасная работа с областями видимости
+ Универсальность

  Поддерживает произвольные языки с помощью пользовательских сигнатур. Позволяя реализовывать универсальные алгоритмы (например, подстановку), которые работают на разных языках без повторной реализации
+ Интеграция с существующими инструментами

  Совместимость с генераторами парсеров и AST, такими как BNF Converter. Такой подход позволяет автоматически преобразовывать синтаксические определения из грамматики BNF в безопасное представления описанное выше.

=== liquid-fixpoint

liquid-fixpoint это фреймворк для решения ограничений в формате CHC (Constrained Horn clause).
liquid-fixpoint использует логический язык первого порядка для представления ограничений со следующими конструкциями
+ Объявление переменных с указанием типа (переводятся в smt сорта)
+ Предикаты, например: конъюнкции, дизъюнкции, отрицания, константы
+ Квалификаторы: Предоставленные пользователем подсказки для помощи решателю
+ Неинтерпретируемые функции, например len
+ CHC

liquid-fixpoint интегрирован с SMT-решателями, такими как Z3 и CVC4. Также важной особенностью является то, что перед тем как отправить ограничение решателю, liquid-fixpoint их оптимизирует

Поскольку liquid-fixpoint реализован на Haskell, имеет богатый API и встроенную поддержку вывода предикатов, а также используется при решении ограничений в проверенном временем LiquidHaskell, было принято решение выбрать этот фреймворк как основу для работы с ограничениями.

== Компоненты фреймворка
В главе проектирования были описание основные компоненты и требования которые должны быть реализованы во фреймворке. В этой главе будут подробно рассмотрены принятые решения, предоставленные интерфейсы и описание реализация основных функций
=== Окружение<c-realization-env>
В обзоре free-foil, было показано, что этот фреймворк предоставляет ряд абстракций которые позволяют обобщенно работать с переменными (см. Var) и их объявлением через параметр binder, который описывает как новые переменные расширяют область видимости. С другой стороны уточняющие типы являются зависимыми. Если посмотреть на тип функции sum, то он будет выглядеть следующим образом

$x:{v : "int" | "true" } -> y:{v : "int" | "true" } -> {v : "int" | v = x + y}$

На этом примере видно, что уточнение в результирующем типе зависит от данных которые которые передаются в аргументы функции. Из этого также видно что у нас типы сами по себе содержат область видимости
- $x:{v : "int" | "true" }$ находится в области $n_1$
- $y:{v : "int" | "true" }$ расширяется переменной $x$ и находится в области $n_2$
- ${v : "int" | v = x + y}$ расширяется переменной $y$ и находится в области $n_3$
- а уточнение $v = x + y$ также расширяется переменной $v$ и уже находится в области $n_4$

Исходя из этой особенности фреймворку нужно предоставить некоторое окружение которое бы предоставляло возможность связывать переменные с типами, с учетом их областей видимости

#figure(
  ```haskell
  data Env sig binder n where
    -- Конструктор описывающий пустое окружение
    EmptyEnv :: Env sig binder Foil.VoidS
    -- Конструктор описывающий расширение окружения одной переменной
    NonEmptyEnv ::
      (Foil.CoSinkable binder, Foil.DExt n l) =>
      -- Окружение в предыдущей области n
      Env sig binder n ->
      -- Новая переменная расширяющая область с n до l
      Foil.NameBinder n l ->
      -- Тип связанный с именем, описанный в виде AST free-foil
      Foil.AST binder sig n ->
      -- Новое окружение в области l
      Env sig binder l
  ```,
  caption: "определение окружения"
)<f-realization-2>

В текущем варианте фреймворка окружение реализовано как связанный список с использованием механизма обобщенных алгебраических типов данных (GADTs) и показано на @f-realization-2. Список расширяется из окружения `Foil.VoidS`, где нет никаких переменных, до окружения с переменными. Каждое новое определение добавляется с учетом текущего окружение и расширяет его из области `n`, до области `l` с при помощи `Foil.NameBinder n l`. Класс типов `Foil.DExt n l` служит подсказкой компилятору Haskell о том, что область `n` расширяется до `l`

Функции для работы с окружением выглядят следующим образом
+ Расширение окружения является конструктором `NonEmptyEnv` и имеет такую же сигнатуру
  ```haskell
  extendedEnv ::
    (Foil.DExt i o, Foil.CoSinkable binder) =>
    Env sig binder i ->
    Foil.NameBinder i o ->
    Foil.AST binder sig i ->
    Env sig binder o
  extendedEnv env binder typ = NonEmptyEnv env binder typ
  ```
+ Поиск типа связанного с переменной выглядит интереснее. В первую очередь благодаря подходу free-foil мы можем гарантировать, что если у нас есть свободная переменная в области n, и есть окружение в области l, и область l расширяет область n (проверяется через связку классов `Foil.DExt`), то у нас гарантированно заданная переменная есть в окружении. Благодаря чему мы можем сделать функцию поиска в окружении тотальной. Код функции представлен на @f-realization-3. В коде несколько раз встречается `error "impossible case"`, это сделано чтобы сделать сопоставление с образом исчерпывающем, и во время исполнение не срабатывают. Из сигнатуры функции можно увидеть что возвращаемый тип должен реализовывать класс IsType. Про него будет рассказано в чуть дальше

#figure(
```haskell
lookupEnv ::
  (Bifunctor sig, IsType sig binder) =>
  -- Текущее окружение
  Env sig binder o ->
  -- Имя переменной
  Foil.Name o ->
  -- Тип связанный с переменный
  Foil.AST binder sig o
lookupEnv env varId = case env of
  EmptyEnv -> error "impossible case"
  NonEmptyEnv env' binder term ->
    if Foil.nameOf binder == varId
      then Foil.sink term
      else
        case Foil.unsinkName binder varId of
          Nothing -> error "impossible case"
          Just varId' -> Foil.sink $ lookupEnv env' varId'
```,
caption: "Поиск в окружении типа связанного с переменной"
)<f-realization-3>

Уже было описана важная гарантия того, что поиск связанного с переменной типа в окружении всегда тотальный, но есть и другая важная особенность: благодаря free-foil у нас есть единообразный формат работы с именами, которые хранятся как ключи в окружении. В дальнейшем это пригодится для генерации переменных Хорна.

=== Типы
Работа с типами описывается в виде следующего контракта, представленного на @f-realization-4.
#figure(
  ```haskell
  class IsType sig binder where
    withPred ::
      Foil.Distinct n =>
      Foil.AST binder sig n ->
      (WithPred sig binder n -> (a, WithPred sig binder n)) ->
      (Maybe a, Foil.AST binder sig n)
    toTypeSignature :: Foil.AST binder sig n -> TypeSignature
  ```,
  caption: "Контракт работы с типами"
)<f-realization-4>

==== Модификация предикатов внутри типов
Функция `withPred` в первую очередь нужна для того, чтобы фреймворк и его пользователи могли получать из типов их предикаты, работать с ними, модифицировать и делать на их основе вычисления. Напомним, что типы уточнения выглядят следующим образом ${v : "int" | "true" }$. В то же время в языке могут быть типы которые не имеют уточнений, например функции.

$arg:{v : "int" | "true" } -> {v : "int" | "true" }$

На данном примере видно, что у типа аргумента и результирующего типа есть свои предикаты, но сам тип функции предиката не имеет.

Давайте подробнее разберем сигнатуру функции `withPred`
```
withPred ::
  Foil.Distinct n =>
  Foil.AST binder sig n ->
  (WithPred sig binder n -> (a, WithPred sig binder n)) ->
  (Maybe a, Foil.AST binder sig n)

data WithPred sig binder i where
  WithPred ::
    ( IsPred sig binder
    , Foil.DExt i o
    ) =>
    Foil.NameBinder i o
    -> Foil.AST binder sig o
    -> WithPred sig binder i
```
- На строке 3 передается тип в таком же формате, как и в окружение, через абстрактное синтаксическое дерево предоставляемое free-foil
- На строке 4, вторым аргументом, передается функция которая производит работу с предикатом внутри типа, если этот предикат есть, и возвращает посчитанное на его основе значение, а также модифицированный предикат (также может остаться без изменений). В случае если модифицируется только предикат и дополнительные вычисления не производятся, то возвращаем значением можно быть элемент типа `()`, также известного как unit имеющий только одно значения.
- На строке 5 показаны возвращаемые значение. Возвращается кортеж из двух элементов
  + Опциональное посчитанное значение. Значение присутствует, если у типа был предикат
  + Заново сконструированный тип, с измененным предикатом
Также был введен специальный тип данных WithPred -- экзистенциальный тип данных, где переменная o появляется только во внутренней сигнатуре, и не появляется в самом типе `WithPred sig binder i`. Это решает две проблемы
+ Кодирование фантомного типа o который появляется только при распаковке типа, и будет каждый раз новый
+ Сохранение гарантии, что предикат внутри WithPred реализует контракт предикатов

==== Сигнатура типа
Как было описано в главе проектирования, сигнатуры типов нужны для определения типов выражений в SMT-решателе. Это требование также является частью контракта работы с типами из @f-realization-4. Финальный вариант сигнатуру типов выглядит представлен на @f-realization-5
#figure(
  ```haskell
  data TypeSignature
    = BoolType
    | IntType
    | VarType Id
    | DataType Id [TypeSignature]
    | FunType TypeSignature TypeSignature
    | ForallType Id TypeSignature
  ```,
  caption: "Определение сигнатуры типов в фреймворке"
)<f-realization-5>
+ Id представляет строковый идентификатор переменных и имен типов
+ BoolType и IntType представляют bool и int соответственно, и являются интерпретируемыми типами
+ VarType представляет переменную типа для параметрического полиморфизма и представляется в виде неинтерпретируемого типа
+ DataType также представляет собой неинтерпретируемый тип, с возможность параметризации другими типами
+ FunType представляет собой тип функций, функции с арностью могут быть представлены как связка нескольких FunType, например

  `FunType IntType (FunType IntType BoolType)`
+ ForallType вводит переменную типа в область видимости типа указанного вторим аргументом

Важно заметить что сигнатура типов не представлена в виде AST из free-foil, это сделано намеренно по причине того, что пользовательские типы уже представлены в виде этого AST и при конвертации будет гарантированна уникальность имен. Эта гарантия избавляет от проблем с конфликтом имен и затенением переменных с учетом того, что дополнительные операции с сигнатурой типов не производятся.

`toTypeSignature :: Foil.AST binder sig n -> TypeSignature`

Сама функция конвертации требуется в контракте работы с типами и по сути является обходом типа с отбросом всех встречающихся предикатов

=== Предикаты
Грамматика предикатов описана ровно так как предполагалось на моменте проектирования и показана на @f-design-1.
Операторы указанные как OP в грамматике представлены следующим набором $=, <=, <, >=, >, +, -, *, and, or$

Контракт который должны реализовывать предикаты модельного языка показан на @f-realization-6

#figure(
  ```haskell
  class IsPred sig binder where
    isUnknown :: Foil.AST binder sig n  -> Bool
    mkAnd :: Foil.AST binder sig n ->
      Foil.AST binder sig n -> Foil.AST binder sig n
    mkEq :: Foil.AST binder sig n ->
      Foil.AST binder sig n -> Foil.AST binder sig n
    mkHornVar :: String -> [Foil.Name n] -> Foil.AST binder sig n
    toPredicate :: Foil.AST binder sig n -> P.Pred
  ```,
  caption: "Контракт предикатов"
)<f-realization-6>
- `isUnknown, mkHornVar` используются для вывода предикатов и описаны в @c-realization-predicate-inference
- `mkAnd, mkEq` нужны для реализации функций усиления предикатов независящих от модельного языка, по сути они просто создают узлы в синтаксическом дереве предикатов с равенством и конъюнкцией
- `toPredicate` необходим для конвертации предикатов модельного языка в предикаты фреймворка

==== Неинтерпретируемые функции
Неинтерпретируемые функции представлены следующим образом

```haskell
data Measure = Measure
  { measureName :: String
  , sort :: TypeSignature
  }
```

Неинтерпретируемые функции могут быть описаны на модельном языке используя типы реализующие контракт указанный выше. Сами функции регистрируются следующим образом

```haskell
mkMeasure ::
  C.IsType sig binder =>
  -- Идентификатор функции
  String ->
  -- Тип функции
  Foil.AST binder sig n ->
  Measure
```

==== Вывод предикатов<c-realization-predicate-inference>

Для вывода предикатов нам нужно объявить переменные Хорна с их сигнатурой, которые будут описывать предикат. а также вставить применение зарегистрированной переменной к аргументам из окружения. Для каждого нового вывода нужно создать новые переменную с уникальным именем. Имена создаются по следующему принципу $k_1, k_2, .., k_n$. Это приводит нас к необходимости поддерживать состояние которое бы хранило все существующие переменные, а также поддерживало индекс следующей.

```haskell
data HornVarsState = HornVarsState
  { nextHornVarIndex :: Int -- Индекс следующей переменной
  , hornVars :: [HornVar] -- Текущий переменные
  }
```

По скольку состояние изменяется с ходом генерации условий корректности, а Haskell является языком с неизменяемыми переменными, то поддержка корректного состояния ложится на плечи пользователя. К счастью в Haskell есть множество инструментов для работы с изменяемыми состояниями, например монада State, а также изменяемые участки памяти, работающие в IO, такие как IORef и MVar.

Места для вывода предикатов должны быть помечены специальной заглушкой, на место которой встанет применение переменной Хорна к окружению. Заглушки могу встречаться в аннотациях типов выставленных программистом, а также в местах уточнения типа полиморфных функций и типов данных после их вывода. Для понимания является ли предикат заглушкой в контракт предикатов добавлена функция
```
isUnknown :: Foil.AST binder sig n  -> Bool
```

В пункте про окружение (см @c-realization-predicate-inference), показывались возможности которое дает предоставленное окружение. В первую очередь все имена переменных описываются через `Foil.Name`, это позволяет нам генерировать новые имена переменных без боязни затенить переменные выше по области видимости, а также и расширять AST модельного языка вставкой свободных переменных через `Var`

Давайте подробно рассмотрим алгоритм замены заглушек на применение переменных Хорна с использованием контрактов которые мы уже ввели.

В первую очередь определим сигнатуру функции которая будет производить замену

```haskell
freshTypeWithPredicate ::
  (Bifunctor sig, Foil.Distinct n, IsType sig binder) =>
  HornVarsState ->
  Env sig binder n ->
  Foil.AST binder sig n ->
  (Foil.AST binder sig n, HornVarsState)
```
В аргументы функции мы передаем состояние `HornVarsState` которое хранит текущие переменные хорна, окружение с переменными и их типами, а так же сам тип в формате AST free-foil. На выходе мы получаем кортеж из типа с модифицированным предикатом и новое состояние. Если же у типа не было предиката, или предикат не был заглушкой, то тип вернется как был, а состояние переменных не изменится.

Первым шагом, на основе окружения нужно собрать все имена и их типы, у которых есть предикат (типы без предикатов не участвуют в условиях корректности). Делается это следующим образом
```haskell
envSorts = flip mapMaybe (envToList env) $ \(name, envTyp) ->
  fst $ withPred envTyp $ \withPredInst ->
    let sort = toTypeSignature envTyp
    in ((name, sort), withPredInst)
```
+ Преобразуем окружение в список пар имен и их типов
+ Делаем проход по полученным парам, и смотрим на их типы. Если у типа был предикат, то вычисляем его сигнатуру, иначе отбрасываем такую пару.
+ На выходе получаем список всех имен переменных и их сигнатуры типов

Следующим шагом нужно обработать сам тип который был передан аргументом
```haskell
 mTypeSort = join . fst $
  withPred argType $ \wp@(WithPred _ p) ->
    let
      sort = if isUnknown p
        then Just $ toTypeSignature argType
        else Nothing
    in (sort, wp)
```
Здесь схема аналогична предыдущему шагу, за исключением того, что помимо наличия предиката, также проверяется то, что он является заглушкой

Последним шагом объявляется переменная Хорна и предикат типа заменяется на ее применение

#pagebreak()

```haskell
case mTypeSort of
  Just typSort ->
    let
      (hornVarName, refinementState')
        = mkFreshHornVar refinementState
            (typSort : map snd envSorts)
      freshedType = snd $ withPred typToFresh
        $ \(WithPred pNameBinder _) ->
          let
            newPred = mkHornVar hornVarName
              ( Foil.nameOf pNameBinder : map fst envSorts )
          in ((), WithPred pNameBinder newPred)
    in (freshedType, refinementState')
  _ -> (typToFresh, refinementState)
```
На основе предыдущего шага делается решение нужно ли модифицировать предикат и если да, то делаются следующие операции
- Создается новая переменная Хорна (5 строка) с учетом сигнатуры модифицируемого типа и сигнатур типов из окружения. На выходе получается имя новой переменной и обновленное состояние
- В строке 7 объявляется модифицированный тип через `withPred`. Внутри типа предикат заменяется на применение новой  переменной Хорна при помощи еще одного элемента контракта предикатов `mkHornVar`

  ```haskell
  mkHornVar ::
    -- Имя переменной
    String ->
    -- Имена аргументов
    [Foil.Name n] ->
    -- Новый предикат в синтаксисе модельного языка
    Foil.AST binder sig n
  ```

  Тут важно подметить что имена переменных используют String, а не формат имени из free-foil, это потому что имена переменных уникально глобально, а не в рамках скоупов, из-за чего отдельная работа с механизмами free-foil не требуется

На выходе получается готовый вывода предикатов в модельном языке, где для его работы нужно только организовать работу с состоянием переменных и вызывать `freshTypeWithPredicate` для типов где могут быть заглушки

=== Ограничения

Ограничения представлены в виде следующей структуры, описывающей предложенный в момент проектирования вариант @f-design-3

```haskell
data Constraint
  = CPred Pred ErrorMessage
  | CAnd [Constraint]
  | CImplication VarId TypeSignature
      Pred Constraint ErrorMessage
```

- `ErrorMessage` представляет из себя текстовое поле которое пользователь указывает во время генерации ограничений. Оно служит для описания контекста где произошла ошибка и может содержать данные о месте, переменных и узлах синтаксического дерева спровоцировавших ошибку
- `CAnd` объединяет несколько ограничений в одно
- `CPred` это лист дерева ограничений, задающий предикат. Этот узел используется как базовый элемент проверки подтипирования уточняющих типов. Из правила ниже в СPred будет записан $q[w := v]$
  #figure(
  $
  &Γ ⊢ ∀ (v : t). p => q[w := v] \
  &——————————— "Sub-Base" \
  &Γ ⊢ b{v:p} <: b{w:q}
  $,
  caption: "Правило подтипирования базовых типов с уточнением"
  )<f-realization-7>
- `CImplication` описывает узел вида $forall (v : t) . p => c$, где $v$ это VarId, $t$ сигнатура типа, $p$ предикат, $c$ ограничение

Функции для создания ограничений выглядят следующим образом
+ `сAnd` дублирует конструктором и служит для объединения ограничений из разных узлов программы
  ```haskell
  cAnd :: [Constraint] -> Constraint
  cAnd = CAnd
  ```
+ `cPed` принимает предикат реализующий контракт `IsPred` и переводит его в формат фреймворка
  ```haskell
  cPred :: IsPred sig binder => Foil.AST binder sig n -> Text -> Constraint
  cPred p = CPred (toPredicate p)
  ```
+ `сImplication` хитрее, потому что импликация возникает в случаях введения новой переменной с ее типом в область или при подтипировании
  #figure(
    ```haskell
    сImplication ::
      ( IsType sig binder, Foil.Distinct n
      , Bifunctor sig, Foil.CoSinkable binder) =>
      -- специальный тип из free-foil хранящий все имена переменных
      Foil.Scope n ->
      -- имя переменной связанное с типом
      Foil.NameBinder n l ->
      -- тип
      Foil.AST binder sig n ->
      -- ограничение с правой стороны импликации
      Constraint ->
      -- сообщение ошибки при нарушении ограничения
      ErrorMessage ->
      -- ограничение с импликацией
      Constraint
    ```,
    caption: "Создание импликации из типа"
  )
  Алгоритм создания импликации выглядит следующим образом. Представим, что у нас есть переменная $x$ с типом ${v : "int" | v >= 0}$. В функцию мы принимаем отдельно `Foil.NameBinder` для $x$ и сам тип, это сделано для того, чтобы в предикате $v >= 0$ заменить все вхождения $v$ на $x$. Такой шаг нужен для того чтобы связать уточнение типа с переменной, которая будет использования в окружении и в ограничениях ниже по дереву (правая сторона импликации). А в случае правила подтипирования (см. @f-realization-7) на место имени переменной $x$ передается $v$ из самого уточнения. Замена вхождения $v$ на $x$ происходит благодаря free-foil, предоставляющего независимую от языка подстановку, что позволяет не требовать от пользователей фреймворка реализовывать ее в виде еще одного контракта

== Резюме
Полученный фреймворк предоставляет следующие основные компоненты
+ Окружение. Реализовано с использование GADTs и free-foil для безопасного управления областями видимости.
  Поддерживает связывание переменных с их типами, включая уточнения, с гарантией тотальности поиска
+ Типы. Предоставлен контракт IsType для работы с типами, включая модификацию предикатов и преобразование в сигнатуры типов для SMT-решателей
+ Предикаты. Грамматика соответствует логике QF_UFLIA (без кванторов, линейная арифметика, неинтерпретируемые функции).
  Предоставлены функции для работы с предикатам в модельном языке, проверки "заглушек" и генерации переменных Хорна для вывода предикатов.
+ Ограничения. Автоматическая генерация ограничений на основе контрактов работы с типами и предикатами.

Ключевыми возможностями является
+ Безопасное управление областями видимости: Гарантируется корректная работа с переменными, избегание конфликтов имён.
+ Автоматический вывод предикатов: Замена "заглушек" на переменные Хорна с последующим выводом уточнений через SMT-решатели.
+ Интеграция с SMT: Автоматическая проверка условий корректности, включая поддержку неинтерпретируемых функций и линейной арифметики.
+ Расширяемость: Возможность добавления пользовательских типов и предикатов через контракты (`IsType`, `IsPred`).
