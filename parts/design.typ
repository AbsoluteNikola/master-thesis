#import "@preview/simplebnf:0.1.1" as bnf

= Проектирование

== Язык предикатов

Типы уточнений дополняют стандартные системы типов логическими предикатами для определения и проверки семантических свойств программ. При разработке фреймворка с типами уточнений выбор базовой логики для этих предикатов имеет решающее значение. Поэтому выбор логики для выражения этих предикатов имеет решающее значение, поскольку он определяет как выразительность системы типов (т.е. диапазон свойств, которые могут быть заданы), так и разрешимость проверки типов (т.е. возможность автоматизации проверки). Слишком выразительная логика чревата неразрешимостью, что делает проверку типов непрактичной, в то время как чрезмерно строгая логика ограничивает полезность уточняющих типов для реальных задач проверки.

=== Основные свойства логики для уточняющих типов

+ *Разрешимость*:
  Выполнимость/валидность формул должна поддаваться алгоритмической проверке.

+ *Выразительность*: Логика должна поддерживать предикаты, относящиеся к практическим свойствам программы (например, арифметические неравенства и инварианты структуры данных).

+ *Эффективность*: Скорость автоматизированной проверки с помощью SMT-решателей должно быть приемлемым для пользователей фреймворка.

+ *Интеграция с SMT-решателями*: Поддержка в современных системами для решения SMT-задач.

=== Сравнение логик
+ Логика первого порядка без кванторов (QF_FOL)
  - *Разрешимость*: Гарантируется для ряда фрагментов, например QF_UFLIA (неинтерпретируемые функции + линейная арифметика).
  - *Выразительность*: Ограничена формулами без кванторов, но достаточна для многих уточнений (например, $x > 0$, $f(x) = y$).
  - *Эффективность*: SMT-решатели разрешают ограничения QF_FOL за миллисекунды с помощью DPLL(T) и процедур, специфичных для различных теорий
  - *Интеграция с SMT-решателями* - нативно поддерживается в большинстве решателей

+ Логика первого порядка с кванторам (FOL)
  - *Разрешимость*: Неразрешимость в целом, ограниченные фрагменты являются нишевыми и в меньшей степени поддерживаются инструментами

  - *Выразительность*: Обеспечивает поддержку предикатов с кванторами, например
    $forall i. (0<=i<=n) ==> "arr"[i] > 0$.


  - *Эффективность*: Обработка квантора приводит к значительным накладным расходам, часто приводящим к тайм-аутам, что
  - *Интеграция с SMT-решателями*: частичная

+ Другие логики
  + Логики высших порядков (Higher-Order Logic, HOL)

    Логики высших порядков позволяют использовать кванторы над функциями и предикатами, что существенно расширяет выразительность. Например, в HOL можно формализовать индуктивные инварианты или свойства рекурсивных структур данных. Однако разрешимость HOL фрагментов крайне ограничена: проверка условий корректности требует интерактивных доказательств, что противоречит требованию автоматизации через SMT-решатели. Кроме того, HOL не поддерживается большинством промышленных SMT-решателей, за исключением специализированных инструментов, что делает её непрактичной для интеграции в фреймворк уточняющих типов.

  + Модальные и временные логики (LTL, CTL)

    Модальные логики, такие как линейная временная логика (LTL) или логика ветвящегося времени (CTL), предназначены для спецификации динамических свойств систем (например, "всегда" или "в будущем"). Хотя они эффективны для верификации протоколов параллелизма или реактивных систем, их семантика несовместима с задачами статической проверки инвариантов данных, которые требуют анализа статических условий корректности, а не временных траекторий.

  + Теории массивов и структур данных

    Многие SMT-решатели поддерживают теории массивов (QF_AUF), позволяющие кодировать операции чтения/записи и инварианты для структур данных. Однако их использование сопряжено с риском. Кроме того, автоматический вывод инвариантов для массивов часто требует ручного задания аксиом, что усложняет интеграцию в систему уточняющих типов, ориентированную на автоматизацию.

В итоге разрешимые без кванторов фрагменты логики первого порядка (QF_FOL) обеспечивают прочную основу для предикатов в уточняющих типах, поскольку они гарантируют баланс между выразительностью и автоматизированной, предсказуемой проверкой. Начинать с фрагмента QF_UFLIA (неинтерпретируемые функции без кванторов и линейная целочисленная арифметика) особенно выгодно, поскольку он охватывает основные теории, необходимые для большинства приложений с уточняющими типами, включая линейную арифметику для числовых инвариантов и неинтерпретированные функции для абстрактных рассуждений об операциях в программном коде. Этот фрагмент хорошо поддерживается SMT-решателями, обеспечивая масштабируемую автоматизированную проверку условий корректности без непредсказуемости или проблем с производительностью. Расширение поддерживаемых теорий возможно лишь при условии строгого контроля за их комбинацией и доказательством сохранения разрешимости, и не будет рассмотрено в этой работе

=== Синтаксис

Синтаксис языка предикатов определяется на @f-design-1 и исходит напрямую из логики первого порядка без кванторов с неинтерпретируемыми функциями и линейной арифметикой целых чисел. Единственным исключением являются переменные Хорна, которые требуются для вывода предикатов в уточняющих типов. Они будет рассмотрены позже

#let predicate-syntax = [
  #set text(style: "italic")
  #grid(
    align: (right, center, left, left, left),
    columns: (1cm, 1cm, auto, auto),
    inset: 0.28em,
    [$p$], [$::=$], [$x, y, z$],   [Переменные],
    none,  [$|$],   [true, false], [Логические значения],
    none,  [$|$],   [$p$ OP $p$],  [Интерпретируемые операторы],
    none,  [$|$],   [$p and p$],   [Конъюнкция],
    none,  [$|$],   [$p or p$],    [Дизъюнкция],
    none,  [$|$],   [$not p$],     [Отрицание],
    none,  [$|$],   [$f(p_1, p_2, ..)$],     [Неинтерпретируемые функции],
    none,  [$|$],   [$k(x, y, ..)$],     [Переменные Хорна],
  )
]

#figure(
  predicate-syntax,
  caption: "Синтаксис языка предикатов"
)<f-design-1>

Для проверки уточняющих типов в модельном языке нужно расширить грамматику самого языка таким образом чтобы язык предикатов был не мощнее представленного на @f-design-1. Предполагается, что в язык будут добавлены предикаты в аналогичном формате, что позволит сделать конвертацию предикатов модельного языка в предикаты фреймворка тривиальным преобразование одного синтаксического дерева в другое. Пример реализации такого подхода будет будет в главе с реализацией подможножества языка Ocaml на предоставленном фреймворке

== Уточняющие типы
Обычно уточняющие типы представляются в формате $e :: {v : T | p }$ где
- $e$ выражение для которого задается уточняющий тип
- $v$ переменная связывающая значение во время исполнение
- $T$ базовый тип выражения
- $p$ называется уточнением типа и представляет собой ограничение множества значений выражения $e$. Например, уточнение в типе $e ::{ v : "int" | v > 0}$ ограничивает множество значений $e$ до множества положительных чисел

=== Доступ к предикатам
Одним из основных контрактов для работы с фреймворком должна быть возможность работы c типами и извлечения из них предикатов, их обработка и модификация. Это дает важную возможность вынесения в фреймворк необходимых и часто используемых функций. Базово такой контракт можно описать как функцию ${v : T | p_1} -> (p_1 -> p_2) -> {v : T | p_2}$
которая принимает тип-уточнение, функцию которая модифицирует предикат и в итоге конструируется новый тип, с новым предикатом. В дальнейшем этот контракт будет расширен и показано его применение для решения широкого ряда задач от вывода предикатов, до реализации функций усиливающих предикат

=== Сигнатура типа
Сорта (sorts) в контексте SMT — это аналоги типов данных в языках программирования. Они определяют множество значений, которые могут принимать переменные, аргументы функций или возвращаемые значения. Каждый сорт задаёт область допустимых значений и правила взаимодействия с операциями теории.

Так как фреймворк отвечает за перевод условий корректности в формат SMT-решателей, нужно предоставить некоторый
формат который бы позволил из уточняющих типов получать сорта.

Для начала рассмотрим какие виды сортов бывают в SMT-LIB
  - Базовые: Описываются одним идентификатором, без аргументов. Пример: Int, Bool
  - Параметризованные: Описываются как идентификатор и аргументы $(<"sort_symbol"> <"sort"_1> ... <"sort"_n>)$. Пример (Pair Int Bool)
  - Функциональные: Представляют функции и описываются как аргументы и возвращаемое значение. Пример: $"Int"  -> "Bool"$


Зная сорта из smt-lib, можно предоставить так называемую сигнатуру типа которая бы покрывал базовые системы типов в функциональных языках. Под сигнатурой типа подразумевается его базовый тип, с удалением всех предикатов и связываемых предикаты переменные. Например тип функции $x:{v : "Int" | v > 0} -> y:{v : "Int" | v > 0} -> {v : "Int" | v = x + y}$ является зависимым, так как тип результата (его уточнение) зависит от аргументов функции, а сигнатура этого типа будет $"Int" -> "Int" -> "Int"$, которая успешно кодируется в сорта SMT.

Основываясь на сортах поддерживаемых smt-lib, сигнатура типов должна поддерживать
- функции
- типы данных, в том числе параметрические
- примитивные типы данных

== Неинтерпретируемые функции
Неинтерпретируемые функции - это функциональные символы в логике и SMT (теории выполнимости по модулю), которые не имеют фиксированной интерпретации или определения, кроме их названия, арности (количества аргументов) и свойства быть тотальными и детерминированными. В отличие от встроенных функций, таких как сложение или умножение, поведение которых определяется определенной теорией (например, арифметикой), неинтерпретируемые функции не имеют какого-либо внутреннего значения или связанных с ними вычислений. Единственным предполагаемым свойством является конгруэнтность: если два входа равны, их выходные данные в соответствии с функцией также должны быть равны (т.е. если $x = y$, то $f(x)=f(y)$).
Неинтерпретируемые функции полезны тем, что они позволяют рассуждать о структуре и взаимосвязях вычислений, не привязываясь к конкретной реализации или семантике. Эта абстракция особенно эффективна при верификации программ, где неинтерпретируемые функции могут моделировать неизвестное или сложное поведение, и в то же время позволяют автоматически рассуждать о равенствах и ограничениях.

Ярким примером использования неинтерпретируемых функции является кодировка длины списка в его уточнении показанная на @f-design-2

#figure(
  ```ocaml
  /*M len : list('a) => int */

  type list('a) =
    | Nil                      => [v| len(v) == 0]
    | Cons (x:'a, xs:list('a)) => [v| len(v) == 1 + len(xs)]
    ;
  ```,
  caption: "Кодировка длины списка в его типе. Пример на языке ocaml"
)<f-design-2>

Имея возможность кодировать типы из модельного языка в известную нам сигнатуру позволяет определять неинтерпретируемые функции в самом модельном языке, никак не требуя отдельно расширять его синтаксис. Уже затем внутри фреймворка, полученная сигнатура будет переводиться в формат SMT-LIB. Таким образом определение и использование неинтерпретируемых функций в модельном языка будет выглядит однородно и лаконично

== Условия корректности

В ходе проверки уточняющих типов генерируются ограничения условий корректности, синтаксис которых представлен на @f-design-3. Ограничения состоят из предикатов без кванторов, показанных на @f-design-1, конъюнкции двух ограничений, подразумевающим, что должно выполняться оба условия, а также импликациеи. Импликация говорит о том, что для каждого $x$ типа $b$, если условие
𝑝 выполняется, значит, должно выполняться и ограничение $c$. Тип b преобразуется в сорт SMT за счет сигнатуры типов описанной выше

#let predicate-syntax = [
  #set text(style: "italic")
  #grid(
    align: (right, center, left, left, left),
    columns: (1cm, 1cm, auto, auto),
    inset: 0.28em,
    [$c$], [$::=$], [$p$],   [Предикат, @f-design-1],
    none,  [$|$],   [$c_1 and c_2$], [Конъюнкция],
    none,  [$|$],   [$forall x : b. p => c$], [Импликация],
  )
]

SMT-решатели алгоритмически определяют, является ли ограничение $c$ валидным, сводя его к
набору формул $c_i$ вида $forall accent(x, arrow). p_i => q_i$ , таким образом, что $c$ валидно, если валидны $c_i$. Валидность каждого $c_i$ определяется путем проверки выполнимости предиката $p_i and not q_i$ (без кванторов):
формула валидна, если не существует удовлетворяющего присваивания

#figure(
  predicate-syntax,
  caption: "Синтаксис условий корректности"
)<f-design-3>

Имея готовые контракты для работы с типами и предикатами получается готовый API для создания ограничений во время проверки типов.

== Вывод предикатов

Двунаправленная проверка типов разделят вывод и проверку типов позволяя аннотировать типы только на верхнем уровне,
а типы подвыражений можно вывести на основе имеющихся аннотаций. После всех выражений уже можно генерировать условия корректности, поскольку для их генерации критично знать тип каждого выражения. Но в случае добавления в язык полиморфизма важной доработкой будет добавление вывода уточнений, что позволит избежать явных аннотаций во всех местах
использования полиморфных функций и типов данных. Теперь проверка уточняющих типов будет разделена на три шага
+ Нужно расширить типы в модельном языке так, чтоб предикат мог представлять собой заглушку.
  И поскольку вывод базовых типов выходит за рамки фреймворка и предоставляется для реализации разработчику языка, все типы указываемые при создании экземпляра полиморфных функций или типов данных должны в предикат этих типов указывать заглушку. Поэтому первым шагом для вывода проверки уточняющих типов должна производиться замена всех заглушек на применение переменных Хорна. В последствии на месте применения этих переменных будет выведен предикат
+ Следующим этапом идет генерация условий корректности, так же как она бы выглядела без вывода предикатов.
  Но здесь важной особенностью является то, что теперь полученные условия корректности содержат применение переменных Хорна, которые напрямую не поддерживаются SMT-решателями
+ В последнем этапе вместо того чтобы просить SMT-решатель определить достоверность VC, мы вызовем другой алгоритм вывода предикатов на основе ограничений и переменных Хорна.
  Этот решатель определяет, есть ли какие-либо уточнения, которыми могут быть заменены применения переменных Хорна, делая результирующие условия корректности верными.

=== Алгоритм

В конечном итоге для проверки уточняющих типов нам нужно в сгенерированных условиях корректности сопоставить для каждой переменной Хорна свой предикат без переменных и так чтобы получившиеся ограничения были верны, если же такого вывода нет, то результат будет Unsat.

Псевдокод функции solve представлен на @f-design-4. На вход подаются собранные во время проверки типов ограничения $c$ и множество предикатов из которых могут быть представлены выведенные предикаты $QQ$. Процедура возвращает SAT если существует такое решение, которое для каждой переменной Хорна сопоставляет конъюнкцию предикатов из $QQ$ и удовлетворяет $c$

#let solve_code = [
  #set text(style: "italic")
  #grid(
    align: (left),
    columns: (auto),
    inset: 0.28em,
    $"solve"(QQ, c) = "if" "SmtValid"(sigma("cs"_p)) "then" "Sat" "else" "Unsat" $,
    $space "where"$,
    $space space "cs" = "flat"(c)$,
    $space space space "cs"_k = {c | c in "cs", c eq.triple forall accent(x, arrow) : accent(t, arrow). p => k(y)} $,
    $space space space "cs"_p = {c | c in "cs", c eq.triple.not forall accent(x, arrow) : accent(t, arrow). p => k(y)$,
    $space space space sigma_0 = lambda k. and { q | q in QQ }$,
    $space space space sigma = "fixpoint"("cs"_k, omega_0)$,
  )
]

#figure(
  solve_code,
  caption: "Алгоритм вывода предикатов"
)<f-design-4>

Алгоритм делится на два этапа
+ Подготовка

  Ограничения $c$ разбиваются на множество ограничений _cs_, каждое их которых вида $forall accent("x : t", arrow). p => p'$, где $p'$ это либо применение переменной Хорна, либо конкретный предикат без переменных хорна. Это множество бьется на два $"cs"_k$ (с переменными) и $"cs"_p$ (без) как показано на @f-design-4. После этого запускается процедура нахождения неподвижной точки для нахождения решения $sigma$ для собранных ограничений $"cs"_k$.

+ Поиск неподвижной точки

  Начальным решением является $sigma_0$, которое каждую переменную Хорна $k$ сопоставляет с конъюнкцией всех предикатов из $QQ$. Любое решение которое сопоставляет переменным Хорна конъюнкции над $QQ$ будет слабее $sigma_0$. Процедура fixpoint итеративно ослабляет решение $sigma$ путем выбора ограничения $c$ которое не удовлетворяется текущим решением $sigma$ и удаляет предикаты из $k$ из начала $c$. Итерации продолжаются пока решение не будет удовлетворять $"cs"_k$. В итоге если полученное решение удовлетворяет также и $"cs"_p$ то solve возвращает успех, иначе неудачу.

У предоставленного алгоритма есть важна особенность в том, что нужно предоставить ему множество предикатов которые могут быть использованы в виде конъюнкции. Используя все те же контракты предикатов и типов, можно получить встроенный в модельный язык синтаксис для ограничения предикатов который примерно может выглядеть как
```qualificator Name(var1: Type, var2: Type) (Predicate)
```
На основе полученной информации станут известны имена переменных, а также сам предикат. После чего полученные предикаты передадутся решателю
